name: build

on: [push,workflow_dispatch]

jobs:
  build-stage:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest]
    steps:
    - name: Clone repo
      uses: actions/checkout@v2

    # - name: Run Integration Tests
    #   run: |


    #     Write-Host "env:PAT $($env:PAT)"
    #     Write-Host "env:EMAIL $($env:EMAIL)"
    #     Write-Host "env:API_VERSION $($env:API_VERSION)"
    #     Write-Host "env:ACCT $($env:ACCT)"

    #     Install-Module VSTeam -Force -Scope CurrentUser
    #     Import-Module VSTeam
    #     #This loads [PesterConfiguration] into scope
    #     Install-Module Pester -Force -Scope CurrentUser
    #     Import-Module Pester
    #     $pesterArgs = [PesterConfiguration]::Default
    #     $pesterArgs.Run.Exit = $true
    #     $pesterArgs.Run.PassThru = $true
    #     $pesterArgs.Output.Verbosity = "Detailed"
    #     $pesterArgs.TestResult.Enabled = $true
    #     $pesterArgs.TestResult.OutputFormat = 'JUnitXml'
    #     $pesterArgs.TestResult.OutputPath = 'test-results.xml'

    #     Invoke-Pester -Configuration $pesterArgs
    #   shell: pwsh
    #   env:
    #     PAT: ${{ secrets.RSAZDOPAT }}
    #     EMAIL: ${{ secrets.RSEMAIL }}
    #     API_VERSION: VSTS
    #     ACCT: razorspoint-vsteamtests
    #   working-directory: './Tests/integration'


    - name: .NET Restore
      shell: pwsh
      run: dotnet restore --no-cache # have to use no cache of the build will fail on Windows

    - name: Build module with help
      if: ${{ matrix.os == 'windows-latest'}}
      shell: pwsh
      run: ./Build-Module.ps1 -installDep -configuration Release -buildHelp

    - name: Build module without help
      if: ${{ matrix.os != 'windows-latest'}}
      shell: pwsh
      run: ./Build-Module.ps1 -installDep -configuration Release

    - name: Run C# unit tests
      shell: pwsh
      run: dotnet test --logger "trx;LogFileName=test-results.trx"

    - name: Publish C# test results
      if: success() || failure()                  # run this step even if previous step failed
      uses: dorny/test-reporter@v1
      with:
        name: C# tests results (${{ matrix.os }}) # name of the check run which will be created
        path: '**/test-results.trx'               # path to test results
        reporter: dotnet-trx                      # format of test results

    - name: Run PowerShell unit tests
      shell: pwsh
      run: |
        Import-Module ./dist/*.psd1
        # This loads [PesterConfiguration] into scope
        Import-Module Pester
        $pesterArgs = [PesterConfiguration]::Default
        $pesterArgs.Run.Exit = $true
        $pesterArgs.Run.PassThru = $false
        $pesterArgs.TestResult.Enabled = $true
        $pesterArgs.Output.Verbosity = "Normal"
        $pesterArgs.Run.Path = './Tests/function'
        $pesterArgs.TestResult.OutputFormat = 'JUnitXml'
        $pesterArgs.TestResult.OutputPath = 'test-results.xml'

        Invoke-Pester -Configuration $pesterArgs

    - name: Publish PowerShell test results
      if: success() || failure()                          # run this step even if previous step failed
      uses: dorny/test-reporter@v1
      with:
        name: PowerShell tests results (${{ matrix.os }}) # name of the check run which will be created
        path: '**/test-results.xml'                       # path to test results
        reporter: jest-junit                              # format of test results

    - name: Copy files to staging folders
      if: ${{ matrix.os == 'windows-latest'}}
      shell: pwsh
      run: |
        Copy-Item -Path "./dist/" -Destination ./staging/VSTeam/dist/ -Recurse -Force
        Copy-Item -Path "./.gitignore","./README.md" -Destination ./staging/VSTeam/ -Recurse -Force
        Copy-Item -Path "./Tests/SampleFiles/" -Destination ./staging/test/Tests/SampleFiles -Recurse -Force
        Copy-Item -Path "./Tests/integration/tests/" -Destination ./staging/test/Tests/integration -Recurse -Force
        Copy-Item -Path "./dist/*.psd1" -Destination ./staging/test/dist -Recurse -Force

    - name: Publish Module
      if: ${{ matrix.os == 'windows-latest'}}
      uses: actions/upload-artifact@v2
      with:
        name: module
        path: "./staging/VSTeam"

    - name: Publish Module
      if: ${{ matrix.os == 'windows-latest'}}
      uses: actions/upload-artifact@v2
      with:
        name: test
        path: "./staging/test"

    - name: Install PSScriptAnalyzer
      if: ${{ matrix.os == 'ubuntu-latest'}}
      shell: pwsh
      run: Install-Module -Name PSScriptAnalyzer -Repository PSGallery -Force -Scope CurrentUser -Verbose

    - name: Run Static Code Analysis
      if: ${{ matrix.os == 'ubuntu-latest'}}
      shell: pwsh
      run: |
        $manifest = Import-PowerShellDataFile ./dist/*.psd1
        $manifest.RequiredModules | ForEach-Object { Import-Module -Name $_ }
        $count = 0
        $r = Invoke-ScriptAnalyzer –Path ./dist –Recurse | Where-Object severity -ne "Information"
        $r | ForEach-Object { Write-Host "::error file=$($_.ScriptPath),line=$($_.Line),col=$($_.Column)::$($_.Message)"; $count++ }
        if($count -ne 0) { throw "Static Code Analysis with error count = $count" }

  package-stage:
    name: Package Management
    needs: build-stage
    runs-on: ubuntu-latest
    steps:
    - name: Download module
      uses: actions/download-artifact@v2
      with:
        name: module
    - name: Install NuGet 5.2.0
      uses: nuget/setup-nuget@v1
      with:
        nuget-version: '5.2.0'
    - name: Install Module Dependencies
      shell: pwsh
      run: |
        # Load the psd1 file so you can read the required modules and install them
        $manifest = Import-PowerShellDataFile ./dist/*.psd1

        # Install each module
        $manifest.RequiredModules | ForEach-Object { Install-Module -Name $_ -Repository PSGallery -Force -Scope CurrentUser -Verbose }

    - name: Pack and push module
      shell: pwsh
      run: |
        Write-Host "Compute Version Number"

        # Load the psd1 file so you can read the version
        $manifest = Import-PowerShellDataFile ./dist/*.psd1

        # load as semantic version
        [version]$sem_version = $manifest.ModuleVersion

        # Build new semantic version with build number
        $package_version = "$($sem_version.Major).$($sem_version.Minor).${{ github.run_number }}"

        Write-Host "Package Version Number: $package_version"

        Write-Host "Create NuSpec from PSD1"

        Install-Module -Name Trackyon.Nuget -Scope CurrentUser -Force

        Write-Host "Convert psd1 into a NuSpec"

        ConvertTo-NuSpec -Path ./dist/VSTeam.psd1

        Write-Host "Pack module"

        Write-Host "nuget pack ./dist/VSTeam.nuspec -NonInteractive -OutputDirectory ./dist -version $package_version -Verbosity Detailed"

        nuget pack ./dist/VSTeam.nuspec -NonInteractive -OutputDirectory ./dist -version $package_version -Verbosity Detailed

        Write-Host "Push module"

        dotnet tool install gpr -g

        gpr push ./dist/*.nupkg -k ${{secrets.GITHUB_TOKEN}} --repository MethodsAndPractices/vsteam

    - name: Upload nuget package as artifact
      uses: actions/upload-artifact@v2
      with:
        name: VSTeamPackage
        path: ./dist/*.nupkg

  testing-stage:
    name: Testing
    needs: package-stage
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest]
    steps:
    - name: Test
      shell: pwsh
      run: Write-Output "Run Tests on ${{ matrix.os }}"
    - name: Download nuget package artifact
      uses: actions/download-artifact@v2
      with:
        name: VSTeamPackage
        path: ./module
    - name: Download integration tests
      uses: actions/download-artifact@v2
      with:
        name: test
        path: ./test

    - name: Install module
      shell: pwsh
      run: |
        $localFeedName = "LocalNugetSource"
        $LocalPSGallery = "LocalPSGallery"
        $moduleName = "VSTeam"
        $dependencies = @("SHiPS","Trackyon.Utils")

        $tempFolder = "$env:TEMP\InstallModuleWorkaround"

        Write-Host "----- create temp folder for local feeds"
        New-Item -Path "$tempFolder\nuget" -Type Directory | Out-Null
        New-Item -Path "$tempFolder\repo" -Type Directory | Out-Null
        New-Item -Path "$tempFolder\install" -Type Directory | Out-Null

        Write-Host "----- Initialize the local nuget feed with VSTeam nupkg and add as local feed"
        nuget init ./module "$tempFolder\nuget"
        nuget sources Add -Name $localFeedName -Source "$tempFolder\nuget"

        Write-Host "----- Download module dependencies as nuget packages"
        nuget sources Add -Name "PSGallery" -Source 'https://www.powershellgallery.com/api/v2/'
        $dependencies | ForEach-Object { nuget install $_ -Source PSGallery -OutputDirectory "$tempFolder\install" }


        Write-Host "----- Add dependencies to local nuget feed as these dependencies are specified as not external"
        nuget init $tempFolder\install "$tempFolder\nuget"


        nuget install $moduleName -Source $localFeedName -OutputDirectory "$tempFolder\install"
        nuget sources remove -name $localFeedName

        $ModuleFolders = Get-ChildItem "$tempFolder\install" -Directory
        Write-Host "----- rename folders"
        Set-Location -Path "$tempFolder\install"
        foreach ($Folder in $ModuleFolders) {
            $ShortName = $Folder.Name -replace '(.*)(\.\d+){3,4}', '$1'
            Move-Item -Path $Folder.Name -Destination $ShortName
        }

        Write-Host "----- Register-PSRepository"
        Register-PSRepository -Name $LocalPSGallery -SourceLocation "$tempFolder\repo"

        Write-Host "----- Publish Dependencies to $$LocalPSGallery"
        $dependencies | ForEach-Object { Publish-Module -Path $tempFolder\install\$_ -Repository $LocalPSGallery}

        Write-Host "----- publish and install VSTeam to $LocalPSGallery"
        $dependencies | Foreach-Object { Install-Module $_ -Force -Scope CurrentUser -Repository $LocalPSGallery }
        Publish-Module -Path $tempFolder\install\$moduleName -Repository $LocalPSGallery
        $dependencies | Foreach-Object { Uninstall-Module $_ }
        Install-Module -Name $moduleName -Repository $LocalPSGallery -AllowClobber -SkipPublisherCheck -Force -Scope CurrentUser


    - name: Install Pester
      run: Install-Module -Name Pester -Repository PSGallery -Force -AllowPrerelease -MinimumVersion "${{ env.PESTER_VERSION }}" -Scope CurrentUser -AllowClobber -SkipPublisherCheck
      shell: pwsh

    - name: Run Integration Tests
      run: |

        Install-Module -Name VSTeam -Repository LocalPSGallery -Force -Scope CurrentUser
        Import-Module VSTeam -Verbose
        #This loads [PesterConfiguration] into scope
        Import-Module Pester
        $pesterArgs = [PesterConfiguration]::Default
        $pesterArgs.Run.Exit = $true
        $pesterArgs.Run.PassThru = $true
        $pesterArgs.Output.Verbosity = "Detailed"
        $pesterArgs.TestResult.Enabled = $true
        $pesterArgs.TestResult.OutputFormat = 'JUnitXml'
        $pesterArgs.TestResult.OutputPath = 'test-results.xml'

        Invoke-Pester -Configuration $pesterArgs
      shell: pwsh
      env:
        PAT: ${{ secrets.AZDOPAT }}
        EMAIL: ${{ secrets.EMAIL }}
        API_VERSION: VSTS
        ACCT: tooltester
      working-directory: './test/Tests/integration'

    - name: Publish PowerShell test results
      if: success() || failure()                          # run this step even if previous step failed
      uses: dorny/test-reporter@v1
      with:
        name: PowerShell tests results (${{ matrix.os }}) # name of the check run which will be created
        path: '**/test-results.xml'                       # path to test results
        reporter: jest-junit

  publish-stage:
    name: PowerShell Gallery
    needs: testing-stage
    # environment: 'PowerShell Gallery'
    runs-on: ubuntu-latest
    steps:
    - name: Publish
      shell: pwsh
      run: Write-Output "Publish to PowerShell Gallery"